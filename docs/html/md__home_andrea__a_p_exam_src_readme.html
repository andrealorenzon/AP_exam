<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Binary Tree: Specifications</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Binary Tree
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Binary tree implementation for AP Exam</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Specifications </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>What you have to submit</h1>
<p>You have to upload only and all the source files you wrote, with a Makefile and a readme.md file where you describe how to compile, run your code and a short report on what you have done and understood.</p>
<p>your code should have no memory leaks. You can check running </p><pre class="fragment">`$ valgrind ./a.out ...`
</pre><p>where the ... means possible additional command line arguments, if any.</p>
<p>your code must be compiled with the flags <code>-Wall -Wextra</code> and no warnings must appear</p>
<h1>Binary search tree</h1>
<p>In this exam you are required to implement a template binary search tree (BST). A BST, is a hierarchical (ordered) data structure where each node can have at most two children, namely, left and right child. Each node stores a pair of a key and the associated value. The binary tree is ordered according to the keys. Given a node N, all the nodes having keys smaller than the key of the node N can be found going left. While all the nodes with a key greater than the key of the node N can be reached going right.</p>
<div class="image">
<img src="https://github.com/asartori86/advanced_programming-2018-19/blob/master/exam/c%2B%2B/.aux/binary.png" alt="Picture"/>
</div>
<p>Practically speaking, given the binary tree in the picture, if you need to insert a new node with key=5, you start from the root node 8, you go left since 5&lt;8, you reach node 3, then you go right, you land in 6, you go left reaching node 4. Node 4 has no right child, so the new node 5 will be the right child of node 4. If a key is already present in the tree, you can choose if replace the value with the newest one, or leave the things as they are.</p>
<p>From the implementation point of view, your node has two pointers left and right pointing to the left and right child respectively. The pointers points to nullptr if they have no children.</p>
<p>It is useful to add an additional pointer (head, root, whatever you like) pointing to the first node, called root node. Tree traversal</p>
<p>The tree must be traversed in order, i.e., if I "print" the tree in the picture, I expect to see on the screen the sequence</p>
<p><code>1 3 4 6 7 8 10 13 14</code></p>
<p>node 1 is the first node, and node 14 is the last one. Assignments</p>
<p>You have to solve the following tasks in C++11 (C++14 and 17 are welcomed as well).</p>
<ul>
<li>implement a template binary search tree</li>
<li>it must be templated on the type of the key and the type of the value associated with it.</li>
<li>optional you can add a third template on the operation used to compare two different keys.</li>
<li>implement proper iterators for your tree (i.e., iterator and const_iterator)</li>
<li>the tree must have at least the following public member function</li>
<li>insert, used to insert a new pair key-value.</li>
<li>clear(), clear the content of the tree.</li>
<li>begin(), return an iterator to the first node (which likely will not be the root node)</li>
<li>end(), return a proper iterator</li>
<li>cbegin(), return a const_iterator to the first node</li>
<li>cend(), return a proper const_iterator</li>
<li>balance(), balance the tree.</li>
<li>find, find a given key and return an iterator to that node. If the key is not found returns end();</li>
<li>optional implement the value_type&amp; operator[](<code>const key_type&amp; k</code>) function int the const and non-const versions). This functions, should return a reference to the value associated to the key k. If the key is not present, a new node with key k is allocated having the value value_type{}.</li>
<li>implement copy and move semantics for the tree.</li>
<li>override the operator put to &lt;&lt; in order to print (in order) key: value of all the nodes in the tree.</li>
<li>Test the performance of the lookups (using the function find) before and after the tree is re-balanced. Use proper numbers (and types) of nodes and look-ups. Does lookup behaves as O(log N)? How your tree compares with std::map? make plots</li>
<li>optional document the code with Doxygen</li>
<li>write a short report</li>
<li>test everything</li>
</ul>
<h1>Hints</h1>
<ul>
<li>you can use <code>std::pair&lt;const key_type,value_type&gt;</code> found in the header utility</li>
<li>use recursive functions</li>
<li>Big hint start coding and using the iterators ASAP. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
